## 1.1 자바스크립트의 동등비교

### 자바스크립트의 데이터타입

자바스크립트는 7개의 원시타입과 1개의 객체타입을 가지고있다.

- 원시타입: Number, String, Boolean, undefined, null, symbol, bigint
- 객체타입: Object( Array, Function )

각 타입이 어떤 역할로 사용되는지에 대한 설명은 생략한다.
하지만, 이 중에서 조금 간단하게 짚고 넘어갈만 한 부분은 다음과 같다.

- null 과 undefined 는 일반적으로 같은 값으로 취급되나, 개발자의 의도에 따라 선언되었지만 할당되지 않은 변수라는 의미와 같이 다르게 취급될 수 있다.
- 대다수의 falsy & truthy 값은 어렵지 않게 유추가 가능하나, 빈 객체와 빈 배열인 {} 와 [] 는 truthy한 값으로 취급되어 예외적으로 조심해야 한다.

### 값을 저장하는 방식의 차이

흔히 Call by value 와 Call by reference 라는 용어를 들어본 적이 있을 것이다.
JS에서도 이와 비슷한 개념이 있는데, 이를 설명하기 위해서는 먼저 메모리에 대한 이해가 필요하다.

```ts
const a = {
  name: "CSKIM999",
  age: 29,
};

const b = {
  name: "CSKIM999",
  age: 29,
};

console.log(a === b); // false
```

이렇게 완전히 같아보이는 두 객체는 메모리 주소가 다르기 때문에 다른 값으로 취급된다.
이는 동등비교(==) 와 완전동등비교(===) 둘 다 false한 결과를 가져온다.

### Object.is

일반적으로 두 객체를 비교하기 위해선 동등비교(==) 와 완전동등비교(===) 를 사용하나, 이 외에도 Object.is 메서드를 사용할 수 있다.
실제로 React의 Dependency Array 에서 이전 상태와 현재 상태를 비교하기 위해 사용되기도 한다.

```ts
Number.NaN === NaN; // false
Object.is(Number.NaN, NaN); // true
```

위와같이 조금 더 개발자의 의도에 맞춰서 적절한 비교를 할 수 있도록 도와주는 메서드이다.

Object.is 메서드는 ES6 에서 추가되었으며 위와같이 완전동등비교(===) 가 가지는 한계를 보완하기 위해 만들어졌다.

### 리액트에서의 동등비교

리액트에서의 동등비교는 주로 상태 업데이트 시 이전 상태와 현재 상태를 비교하는 과정에서 사용된다.
이 과정에서 사용되는 것이 바로 위에서 설명한 Object.is 메서드이다.

하지만 단순히 Object.is 메서드를 사용하는 것 뿐만 아니라 그 객체의 1Depth 까지 비교한다는 점이 특징이다.

리액트에서의 비교를 요약하자면, Object.is 메서드를 사용하여 1차적으로 비교하고, 그 내부에서의 객체 단 얕은 비교를 진행한다.

> 왜 1Depth 까지만 비교할까? : 리액트에서 사용되는 JSX props 는 객체이고 기본적으로 리액트는 props에서 꺼내온 값을 렌더링하는 것을 권장하므로 그 이상의 깊은 비교는 필요하지 않다.

반대로 이것을 다시 생각해보자면, 1Depth 이상의 값이 변화하는 객체를 의존성배열에 넣는다면 의도치 않은 갱신이 발생할 수 있다.
